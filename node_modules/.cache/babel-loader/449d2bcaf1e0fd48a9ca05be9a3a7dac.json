{"ast":null,"code":"'use strict';\n\nvar STREAM = require('stream'),\n    UTIL = require('util'),\n    StringDecoder = require('string_decoder').StringDecoder;\n\nfunction MemoryReadableStream(data, options) {\n  if (!(this instanceof MemoryReadableStream)) return new MemoryReadableStream(data, options);\n  MemoryReadableStream.super_.call(this, options);\n  this.init(data, options);\n}\n\nUTIL.inherits(MemoryReadableStream, STREAM.Readable);\n\nfunction MemoryWritableStream(data, options) {\n  if (!(this instanceof MemoryWritableStream)) return new MemoryWritableStream(data, options);\n  MemoryWritableStream.super_.call(this, options);\n  this.init(data, options);\n}\n\nUTIL.inherits(MemoryWritableStream, STREAM.Writable);\n\nfunction MemoryDuplexStream(data, options) {\n  if (!(this instanceof MemoryDuplexStream)) return new MemoryDuplexStream(data, options);\n  MemoryDuplexStream.super_.call(this, options);\n  this.init(data, options);\n}\n\nUTIL.inherits(MemoryDuplexStream, STREAM.Duplex);\n\nMemoryReadableStream.prototype.init = MemoryWritableStream.prototype.init = MemoryDuplexStream.prototype.init = function init(data, options) {\n  var self = this;\n  this.queue = [];\n\n  if (data) {\n    if (!Array.isArray(data)) {\n      data = [data];\n    }\n\n    data.forEach(function (chunk) {\n      if (!(chunk instanceof Buffer)) {\n        chunk = new Buffer(chunk);\n      }\n\n      self.queue.push(chunk);\n    });\n  }\n\n  options = options || {};\n  this.maxbufsize = options.hasOwnProperty('maxbufsize') ? options.maxbufsize : null;\n  this.bufoverflow = options.hasOwnProperty('bufoverflow') ? options.bufoverflow : null;\n  this.frequence = options.hasOwnProperty('frequence') ? options.frequence : null;\n};\n\nfunction MemoryStream(data, options) {\n  if (!(this instanceof MemoryStream)) return new MemoryStream(data, options);\n  options = options || {};\n  var readable = options.hasOwnProperty('readable') ? options.readable : true,\n      writable = options.hasOwnProperty('writable') ? options.writable : true;\n\n  if (readable && writable) {\n    return new MemoryDuplexStream(data, options);\n  } else if (readable) {\n    return new MemoryReadableStream(data, options);\n  } else if (writable) {\n    return new MemoryWritableStream(data, options);\n  } else {\n    throw new Error(\"Unknown stream type  Readable, Writable or Duplex \");\n  }\n}\n\nMemoryStream.createReadStream = function (data, options) {\n  options = options || {};\n  options.readable = true;\n  options.writable = false;\n  return new MemoryStream(data, options);\n};\n\nMemoryStream.createWriteStream = function (data, options) {\n  options = options || {};\n  options.readable = false;\n  options.writable = true;\n  return new MemoryStream(data, options);\n};\n\nMemoryReadableStream.prototype._read = MemoryDuplexStream.prototype._read = function _read(n) {\n  var self = this,\n      frequence = self.frequence || 0,\n      wait_data = this instanceof STREAM.Duplex && !this._writableState.finished ? true : false;\n\n  if (!this.queue.length && !wait_data) {\n    this.push(null); // finish stream\n  } else if (this.queue.length) {\n    setTimeout(function () {\n      if (self.queue.length) {\n        var chunk = self.queue.shift();\n\n        if (chunk && !self._readableState.ended) {\n          if (!self.push(chunk)) {\n            self.queue.unshift(chunk);\n          }\n        }\n      }\n    }, frequence);\n  }\n};\n\nMemoryWritableStream.prototype._write = MemoryDuplexStream.prototype._write = function _write(chunk, encoding, cb) {\n  var decoder = null;\n\n  try {\n    decoder = this.decodeStrings && encoding ? new StringDecoder(encoding) : null;\n  } catch (err) {\n    return cb(err);\n  }\n\n  var decoded_chunk = decoder ? decoder.write(chunk) : chunk,\n      queue_size = this._getQueueSize(),\n      chunk_size = decoded_chunk.length;\n\n  if (this.maxbufsize && queue_size + chunk_size > this.maxbufsize) {\n    if (this.bufoverflow) {\n      return cb(\"Buffer overflowed (\" + this.bufoverflow + \"/\" + queue_size + \")\");\n    } else {\n      return cb();\n    }\n  }\n\n  if (this instanceof STREAM.Duplex) {\n    while (this.queue.length) {\n      this.push(this.queue.shift());\n    }\n\n    this.push(decoded_chunk);\n  } else {\n    this.queue.push(decoded_chunk);\n  }\n\n  cb();\n};\n\nMemoryDuplexStream.prototype.end = function (chunk, encoding, cb) {\n  var self = this;\n  return MemoryDuplexStream.super_.prototype.end.call(this, chunk, encoding, function () {\n    self.push(null); //finish readble stream too\n\n    if (cb) cb();\n  });\n};\n\nMemoryReadableStream.prototype._getQueueSize = MemoryWritableStream.prototype._getQueueSize = MemoryDuplexStream.prototype._getQueueSize = function () {\n  var queuesize = 0,\n      i;\n\n  for (i = 0; i < this.queue.length; i++) {\n    queuesize += Array.isArray(this.queue[i]) ? this.queue[i][0].length : this.queue[i].length;\n  }\n\n  return queuesize;\n};\n\nMemoryWritableStream.prototype.toString = MemoryDuplexStream.prototype.toString = MemoryReadableStream.prototype.toString = MemoryWritableStream.prototype.getAll = MemoryDuplexStream.prototype.getAll = MemoryReadableStream.prototype.getAll = function () {\n  var self = this,\n      ret = '';\n  this.queue.forEach(function (data) {\n    ret += data;\n  });\n  return ret;\n};\n\nMemoryWritableStream.prototype.toBuffer = MemoryDuplexStream.prototype.toBuffer = MemoryReadableStream.prototype.toBuffer = function () {\n  var buffer = new Buffer(this._getQueueSize()),\n      currentOffset = 0;\n  this.queue.forEach(function (data) {\n    var data_buffer = data instanceof Buffer ? data : new Buffer(data);\n    data_buffer.copy(buffer, currentOffset);\n    currentOffset += data.length;\n  });\n  return buffer;\n};\n\nmodule.exports = MemoryStream;","map":{"version":3,"sources":["/home/codaruuu/Desktop/reactClient/remixclient/node_modules/memorystream/index.js"],"names":["STREAM","require","UTIL","StringDecoder","MemoryReadableStream","data","options","super_","call","init","inherits","Readable","MemoryWritableStream","Writable","MemoryDuplexStream","Duplex","prototype","self","queue","Array","isArray","forEach","chunk","Buffer","push","maxbufsize","hasOwnProperty","bufoverflow","frequence","MemoryStream","readable","writable","Error","createReadStream","createWriteStream","_read","n","wait_data","_writableState","finished","length","setTimeout","shift","_readableState","ended","unshift","_write","encoding","cb","decoder","decodeStrings","err","decoded_chunk","write","queue_size","_getQueueSize","chunk_size","end","queuesize","i","toString","getAll","ret","toBuffer","buffer","currentOffset","data_buffer","copy","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;AAAA,IACIC,IAAI,GAAGD,OAAO,CAAC,MAAD,CADlB;AAAA,IAEIE,aAAa,GAAGF,OAAO,CAAC,gBAAD,CAAP,CAA0BE,aAF9C;;AAIA,SAASC,oBAAT,CAA8BC,IAA9B,EAAoCC,OAApC,EAA6C;AACzC,MAAI,EAAE,gBAAgBF,oBAAlB,CAAJ,EACI,OAAO,IAAIA,oBAAJ,CAAyBC,IAAzB,EAA+BC,OAA/B,CAAP;AACJF,EAAAA,oBAAoB,CAACG,MAArB,CAA4BC,IAA5B,CAAiC,IAAjC,EAAuCF,OAAvC;AACA,OAAKG,IAAL,CAAUJ,IAAV,EAAgBC,OAAhB;AACH;;AACDJ,IAAI,CAACQ,QAAL,CAAcN,oBAAd,EAAoCJ,MAAM,CAACW,QAA3C;;AAGA,SAASC,oBAAT,CAA8BP,IAA9B,EAAoCC,OAApC,EAA6C;AACzC,MAAI,EAAE,gBAAgBM,oBAAlB,CAAJ,EACI,OAAO,IAAIA,oBAAJ,CAAyBP,IAAzB,EAA+BC,OAA/B,CAAP;AACJM,EAAAA,oBAAoB,CAACL,MAArB,CAA4BC,IAA5B,CAAiC,IAAjC,EAAuCF,OAAvC;AACA,OAAKG,IAAL,CAAUJ,IAAV,EAAgBC,OAAhB;AACH;;AACDJ,IAAI,CAACQ,QAAL,CAAcE,oBAAd,EAAoCZ,MAAM,CAACa,QAA3C;;AAGA,SAASC,kBAAT,CAA4BT,IAA5B,EAAkCC,OAAlC,EAA2C;AACvC,MAAI,EAAE,gBAAgBQ,kBAAlB,CAAJ,EACI,OAAO,IAAIA,kBAAJ,CAAuBT,IAAvB,EAA6BC,OAA7B,CAAP;AACJQ,EAAAA,kBAAkB,CAACP,MAAnB,CAA0BC,IAA1B,CAA+B,IAA/B,EAAqCF,OAArC;AACA,OAAKG,IAAL,CAAUJ,IAAV,EAAgBC,OAAhB;AACH;;AACDJ,IAAI,CAACQ,QAAL,CAAcI,kBAAd,EAAkCd,MAAM,CAACe,MAAzC;;AAGAX,oBAAoB,CAACY,SAArB,CAA+BP,IAA/B,GACAG,oBAAoB,CAACI,SAArB,CAA+BP,IAA/B,GACAK,kBAAkB,CAACE,SAAnB,CAA6BP,IAA7B,GAAoC,SAASA,IAAT,CAAeJ,IAAf,EAAqBC,OAArB,EAA8B;AAC9D,MAAIW,IAAI,GAAG,IAAX;AACA,OAAKC,KAAL,GAAa,EAAb;;AAEA,MAAIb,IAAJ,EAAU;AACN,QAAI,CAACc,KAAK,CAACC,OAAN,CAAcf,IAAd,CAAL,EAA0B;AACtBA,MAAAA,IAAI,GAAG,CAAEA,IAAF,CAAP;AACH;;AAEDA,IAAAA,IAAI,CAACgB,OAAL,CAAa,UAAUC,KAAV,EAAiB;AAC1B,UAAI,EAAEA,KAAK,YAAYC,MAAnB,CAAJ,EAAgC;AAC5BD,QAAAA,KAAK,GAAG,IAAIC,MAAJ,CAAWD,KAAX,CAAR;AACH;;AACDL,MAAAA,IAAI,CAACC,KAAL,CAAWM,IAAX,CAAgBF,KAAhB;AACH,KALD;AAOH;;AAEDhB,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,OAAKmB,UAAL,GAAkBnB,OAAO,CAACoB,cAAR,CAAuB,YAAvB,IAAuCpB,OAAO,CAACmB,UAA/C,GACR,IADV;AAEA,OAAKE,WAAL,GAAmBrB,OAAO,CAACoB,cAAR,CAAuB,aAAvB,IAAwCpB,OAAO,CAACqB,WAAhD,GACT,IADV;AAEA,OAAKC,SAAL,GAAiBtB,OAAO,CAACoB,cAAR,CAAuB,WAAvB,IAAsCpB,OAAO,CAACsB,SAA9C,GACP,IADV;AAEH,CA5BD;;AA8BA,SAASC,YAAT,CAAuBxB,IAAvB,EAA6BC,OAA7B,EAAsC;AAClC,MAAI,EAAE,gBAAgBuB,YAAlB,CAAJ,EACI,OAAO,IAAIA,YAAJ,CAAiBxB,IAAjB,EAAuBC,OAAvB,CAAP;AAEJA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,MAAIwB,QAAQ,GAAGxB,OAAO,CAACoB,cAAR,CAAuB,UAAvB,IAAqCpB,OAAO,CAACwB,QAA7C,GAAwD,IAAvE;AAAA,MACIC,QAAQ,GAAGzB,OAAO,CAACoB,cAAR,CAAuB,UAAvB,IAAqCpB,OAAO,CAACyB,QAA7C,GAAwD,IADvE;;AAGA,MAAID,QAAQ,IAAIC,QAAhB,EAA0B;AACtB,WAAO,IAAIjB,kBAAJ,CAAuBT,IAAvB,EAA6BC,OAA7B,CAAP;AACH,GAFD,MAEO,IAAIwB,QAAJ,EAAc;AACjB,WAAO,IAAI1B,oBAAJ,CAAyBC,IAAzB,EAA+BC,OAA/B,CAAP;AACH,GAFM,MAEA,IAAIyB,QAAJ,EAAc;AACjB,WAAO,IAAInB,oBAAJ,CAAyBP,IAAzB,EAA+BC,OAA/B,CAAP;AACH,GAFM,MAEA;AACH,UAAM,IAAI0B,KAAJ,CAAU,oDAAV,CAAN;AACH;AACJ;;AAGDH,YAAY,CAACI,gBAAb,GAAgC,UAAU5B,IAAV,EAAgBC,OAAhB,EAAyB;AACrDA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACAA,EAAAA,OAAO,CAACwB,QAAR,GAAmB,IAAnB;AACAxB,EAAAA,OAAO,CAACyB,QAAR,GAAmB,KAAnB;AAEA,SAAO,IAAIF,YAAJ,CAAiBxB,IAAjB,EAAuBC,OAAvB,CAAP;AACH,CAND;;AASAuB,YAAY,CAACK,iBAAb,GAAiC,UAAU7B,IAAV,EAAgBC,OAAhB,EAAyB;AACtDA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACAA,EAAAA,OAAO,CAACwB,QAAR,GAAmB,KAAnB;AACAxB,EAAAA,OAAO,CAACyB,QAAR,GAAmB,IAAnB;AAEA,SAAO,IAAIF,YAAJ,CAAiBxB,IAAjB,EAAuBC,OAAvB,CAAP;AACH,CAND;;AASAF,oBAAoB,CAACY,SAArB,CAA+BmB,KAA/B,GACArB,kBAAkB,CAACE,SAAnB,CAA6BmB,KAA7B,GAAqC,SAASA,KAAT,CAAgBC,CAAhB,EAAmB;AACpD,MAAInB,IAAI,GAAG,IAAX;AAAA,MACIW,SAAS,GAAGX,IAAI,CAACW,SAAL,IAAkB,CADlC;AAAA,MAEIS,SAAS,GAAG,gBAAgBrC,MAAM,CAACe,MAAvB,IAAiC,CAAE,KAAKuB,cAAL,CAAoBC,QAAvD,GAAkE,IAAlE,GAAyE,KAFzF;;AAGA,MAAK,CAAE,KAAKrB,KAAL,CAAWsB,MAAb,IAAuB,CAAEH,SAA9B,EAAyC;AACrC,SAAKb,IAAL,CAAU,IAAV,EADqC,CACrB;AACnB,GAFD,MAEO,IAAI,KAAKN,KAAL,CAAWsB,MAAf,EAAuB;AAC1BC,IAAAA,UAAU,CAAC,YAAY;AACnB,UAAIxB,IAAI,CAACC,KAAL,CAAWsB,MAAf,EAAuB;AACnB,YAAIlB,KAAK,GAAGL,IAAI,CAACC,KAAL,CAAWwB,KAAX,EAAZ;;AACA,YAAIpB,KAAK,IAAI,CAAEL,IAAI,CAAC0B,cAAL,CAAoBC,KAAnC,EAA0C;AACtC,cAAK,CAAE3B,IAAI,CAACO,IAAL,CAAUF,KAAV,CAAP,EAA0B;AACtBL,YAAAA,IAAI,CAACC,KAAL,CAAW2B,OAAX,CAAmBvB,KAAnB;AACH;AACJ;AACJ;AACJ,KATS,EASPM,SATO,CAAV;AAUH;AACJ,CAnBD;;AAsBAhB,oBAAoB,CAACI,SAArB,CAA+B8B,MAA/B,GACAhC,kBAAkB,CAACE,SAAnB,CAA6B8B,MAA7B,GAAsC,SAASA,MAAT,CAAiBxB,KAAjB,EAAwByB,QAAxB,EAAkCC,EAAlC,EAAsC;AACxE,MAAIC,OAAO,GAAG,IAAd;;AACA,MAAI;AACAA,IAAAA,OAAO,GAAG,KAAKC,aAAL,IAAsBH,QAAtB,GAAiC,IAAI5C,aAAJ,CAAkB4C,QAAlB,CAAjC,GAA+D,IAAzE;AACH,GAFD,CAEE,OAAOI,GAAP,EAAW;AACT,WAAOH,EAAE,CAACG,GAAD,CAAT;AACH;;AAED,MAAIC,aAAa,GAAGH,OAAO,GAAGA,OAAO,CAACI,KAAR,CAAc/B,KAAd,CAAH,GAA0BA,KAArD;AAAA,MACIgC,UAAU,GAAG,KAAKC,aAAL,EADjB;AAAA,MAEIC,UAAU,GAAGJ,aAAa,CAACZ,MAF/B;;AAIA,MAAI,KAAKf,UAAL,IAAoB6B,UAAU,GAAGE,UAAd,GAA4B,KAAK/B,UAAxD,EAAqE;AACjE,QAAI,KAAKE,WAAT,EAAsB;AAClB,aAAOqB,EAAE,CAAC,wBAAwB,KAAKrB,WAA7B,GAA2C,GAA3C,GAAiD2B,UAAjD,GAA8D,GAA/D,CAAT;AACH,KAFD,MAEO;AACH,aAAON,EAAE,EAAT;AACH;AACJ;;AAED,MAAI,gBAAgBhD,MAAM,CAACe,MAA3B,EAAmC;AAC/B,WAAO,KAAKG,KAAL,CAAWsB,MAAlB,EAA0B;AACtB,WAAKhB,IAAL,CAAU,KAAKN,KAAL,CAAWwB,KAAX,EAAV;AACH;;AACD,SAAKlB,IAAL,CAAU4B,aAAV;AACH,GALD,MAKO;AACH,SAAKlC,KAAL,CAAWM,IAAX,CAAgB4B,aAAhB;AACH;;AACDJ,EAAAA,EAAE;AACL,CA9BD;;AAiCAlC,kBAAkB,CAACE,SAAnB,CAA6ByC,GAA7B,GAAmC,UAAUnC,KAAV,EAAiByB,QAAjB,EAA2BC,EAA3B,EAA+B;AAC9D,MAAI/B,IAAI,GAAG,IAAX;AACA,SAAOH,kBAAkB,CAACP,MAAnB,CAA0BS,SAA1B,CAAoCyC,GAApC,CAAwCjD,IAAxC,CAA6C,IAA7C,EAAmDc,KAAnD,EAA0DyB,QAA1D,EAAoE,YAAY;AACnF9B,IAAAA,IAAI,CAACO,IAAL,CAAU,IAAV,EADmF,CACnE;;AAChB,QAAIwB,EAAJ,EAAQA,EAAE;AACb,GAHM,CAAP;AAIH,CAND;;AASA5C,oBAAoB,CAACY,SAArB,CAA+BuC,aAA/B,GACA3C,oBAAoB,CAACI,SAArB,CAA+BuC,aAA/B,GACAzC,kBAAkB,CAACE,SAAnB,CAA6BuC,aAA7B,GAA6C,YAAY;AACrD,MAAIG,SAAS,GAAG,CAAhB;AAAA,MAAmBC,CAAnB;;AACA,OAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,KAAKzC,KAAL,CAAWsB,MAA3B,EAAmCmB,CAAC,EAApC,EAAwC;AACpCD,IAAAA,SAAS,IAAIvC,KAAK,CAACC,OAAN,CAAc,KAAKF,KAAL,CAAWyC,CAAX,CAAd,IAA+B,KAAKzC,KAAL,CAAWyC,CAAX,EAAc,CAAd,EAAiBnB,MAAhD,GACH,KAAKtB,KAAL,CAAWyC,CAAX,EAAcnB,MADxB;AAEH;;AACD,SAAOkB,SAAP;AACH,CATD;;AAYA9C,oBAAoB,CAACI,SAArB,CAA+B4C,QAA/B,GACA9C,kBAAkB,CAACE,SAAnB,CAA6B4C,QAA7B,GACAxD,oBAAoB,CAACY,SAArB,CAA+B4C,QAA/B,GACAhD,oBAAoB,CAACI,SAArB,CAA+B6C,MAA/B,GACA/C,kBAAkB,CAACE,SAAnB,CAA6B6C,MAA7B,GACAzD,oBAAoB,CAACY,SAArB,CAA+B6C,MAA/B,GAAwC,YAAY;AAChD,MAAI5C,IAAI,GAAG,IAAX;AAAA,MACI6C,GAAG,GAAG,EADV;AAEA,OAAK5C,KAAL,CAAWG,OAAX,CAAmB,UAAUhB,IAAV,EAAgB;AAC/ByD,IAAAA,GAAG,IAAIzD,IAAP;AACH,GAFD;AAGA,SAAOyD,GAAP;AACH,CAZD;;AAeAlD,oBAAoB,CAACI,SAArB,CAA+B+C,QAA/B,GACAjD,kBAAkB,CAACE,SAAnB,CAA6B+C,QAA7B,GACA3D,oBAAoB,CAACY,SAArB,CAA+B+C,QAA/B,GAA0C,YAAY;AAClD,MAAIC,MAAM,GAAG,IAAIzC,MAAJ,CAAW,KAAKgC,aAAL,EAAX,CAAb;AAAA,MACIU,aAAa,GAAG,CADpB;AAGA,OAAK/C,KAAL,CAAWG,OAAX,CAAmB,UAAUhB,IAAV,EAAgB;AAC/B,QAAI6D,WAAW,GAAG7D,IAAI,YAAYkB,MAAhB,GAAyBlB,IAAzB,GAAgC,IAAIkB,MAAJ,CAAWlB,IAAX,CAAlD;AACA6D,IAAAA,WAAW,CAACC,IAAZ,CAAiBH,MAAjB,EAAyBC,aAAzB;AACAA,IAAAA,aAAa,IAAI5D,IAAI,CAACmC,MAAtB;AACH,GAJD;AAKA,SAAOwB,MAAP;AACH,CAZD;;AAeAI,MAAM,CAACC,OAAP,GAAiBxC,YAAjB","sourcesContent":["'use strict';\n\nvar STREAM = require('stream'),\n    UTIL = require('util'),\n    StringDecoder = require('string_decoder').StringDecoder;\n\nfunction MemoryReadableStream(data, options) {\n    if (!(this instanceof MemoryReadableStream))\n        return new MemoryReadableStream(data, options);\n    MemoryReadableStream.super_.call(this, options);\n    this.init(data, options);\n}\nUTIL.inherits(MemoryReadableStream, STREAM.Readable);\n\n\nfunction MemoryWritableStream(data, options) {\n    if (!(this instanceof MemoryWritableStream))\n        return new MemoryWritableStream(data, options);\n    MemoryWritableStream.super_.call(this, options);\n    this.init(data, options);\n}\nUTIL.inherits(MemoryWritableStream, STREAM.Writable);\n\n\nfunction MemoryDuplexStream(data, options) {\n    if (!(this instanceof MemoryDuplexStream))\n        return new MemoryDuplexStream(data, options);\n    MemoryDuplexStream.super_.call(this, options);\n    this.init(data, options);\n}\nUTIL.inherits(MemoryDuplexStream, STREAM.Duplex);\n\n\nMemoryReadableStream.prototype.init =\nMemoryWritableStream.prototype.init =\nMemoryDuplexStream.prototype.init = function init (data, options) {\n    var self = this;\n    this.queue = [];\n\n    if (data) {\n        if (!Array.isArray(data)) {\n            data = [ data ];\n        }\n\n        data.forEach(function (chunk) {\n            if (!(chunk instanceof Buffer)) {\n                chunk = new Buffer(chunk);\n            }\n            self.queue.push(chunk);\n        });\n\n    }\n    \n    options = options || {};\n    \n    this.maxbufsize = options.hasOwnProperty('maxbufsize') ? options.maxbufsize\n            : null;\n    this.bufoverflow = options.hasOwnProperty('bufoverflow') ? options.bufoverflow\n            : null;\n    this.frequence = options.hasOwnProperty('frequence') ? options.frequence\n            : null;\n};\n\nfunction MemoryStream (data, options) {\n    if (!(this instanceof MemoryStream))\n        return new MemoryStream(data, options);\n    \n    options = options || {};\n    \n    var readable = options.hasOwnProperty('readable') ? options.readable : true,\n        writable = options.hasOwnProperty('writable') ? options.writable : true;\n    \n    if (readable && writable) {\n        return new MemoryDuplexStream(data, options);\n    } else if (readable) {\n        return new MemoryReadableStream(data, options);\n    } else if (writable) {\n        return new MemoryWritableStream(data, options);\n    } else {\n        throw new Error(\"Unknown stream type  Readable, Writable or Duplex \");\n    }\n}\n\n\nMemoryStream.createReadStream = function (data, options) {\n    options = options || {};\n    options.readable = true;\n    options.writable = false;\n\n    return new MemoryStream(data, options);\n};\n\n\nMemoryStream.createWriteStream = function (data, options) {\n    options = options || {};\n    options.readable = false;\n    options.writable = true;\n\n    return new MemoryStream(data, options);\n};\n\n\nMemoryReadableStream.prototype._read =\nMemoryDuplexStream.prototype._read = function _read (n) {\n    var self = this,\n        frequence = self.frequence || 0,\n        wait_data = this instanceof STREAM.Duplex && ! this._writableState.finished ? true : false;\n    if ( ! this.queue.length && ! wait_data) {\n        this.push(null);// finish stream\n    } else if (this.queue.length) {\n        setTimeout(function () {\n            if (self.queue.length) {\n                var chunk = self.queue.shift();\n                if (chunk && ! self._readableState.ended) {\n                    if ( ! self.push(chunk) ) {\n                        self.queue.unshift(chunk);\n                    }\n                }\n            }\n        }, frequence);\n    }\n};\n\n\nMemoryWritableStream.prototype._write =\nMemoryDuplexStream.prototype._write = function _write (chunk, encoding, cb) {\n    var decoder = null;\n    try {\n        decoder = this.decodeStrings && encoding ? new StringDecoder(encoding) : null;\n    } catch (err){\n        return cb(err);\n    }\n    \n    var decoded_chunk = decoder ? decoder.write(chunk) : chunk,\n        queue_size = this._getQueueSize(),\n        chunk_size = decoded_chunk.length;\n    \n    if (this.maxbufsize && (queue_size + chunk_size) > this.maxbufsize ) {\n        if (this.bufoverflow) {\n            return cb(\"Buffer overflowed (\" + this.bufoverflow + \"/\" + queue_size + \")\");\n        } else {\n            return cb();\n        }\n    }\n    \n    if (this instanceof STREAM.Duplex) {\n        while (this.queue.length) {\n            this.push(this.queue.shift());\n        }\n        this.push(decoded_chunk);\n    } else {\n        this.queue.push(decoded_chunk);\n    }\n    cb();\n};\n\n\nMemoryDuplexStream.prototype.end = function (chunk, encoding, cb) {\n    var self = this;\n    return MemoryDuplexStream.super_.prototype.end.call(this, chunk, encoding, function () {\n        self.push(null);//finish readble stream too\n        if (cb) cb();\n    });\n};\n\n\nMemoryReadableStream.prototype._getQueueSize =  \nMemoryWritableStream.prototype._getQueueSize = \nMemoryDuplexStream.prototype._getQueueSize = function () {\n    var queuesize = 0, i;\n    for (i = 0; i < this.queue.length; i++) {\n        queuesize += Array.isArray(this.queue[i]) ? this.queue[i][0].length\n                : this.queue[i].length;\n    }\n    return queuesize;\n};\n\n\nMemoryWritableStream.prototype.toString = \nMemoryDuplexStream.prototype.toString = \nMemoryReadableStream.prototype.toString = \nMemoryWritableStream.prototype.getAll = \nMemoryDuplexStream.prototype.getAll = \nMemoryReadableStream.prototype.getAll = function () {\n    var self = this,\n        ret = '';\n    this.queue.forEach(function (data) {\n        ret += data;\n    });\n    return ret;\n};\n\n\nMemoryWritableStream.prototype.toBuffer = \nMemoryDuplexStream.prototype.toBuffer = \nMemoryReadableStream.prototype.toBuffer = function () {\n    var buffer = new Buffer(this._getQueueSize()),\n        currentOffset = 0;\n\n    this.queue.forEach(function (data) {\n        var data_buffer = data instanceof Buffer ? data : new Buffer(data);\n        data_buffer.copy(buffer, currentOffset);\n        currentOffset += data.length;\n    });\n    return buffer;\n};\n\n\nmodule.exports = MemoryStream;\n"]},"metadata":{},"sourceType":"script"}