{"ast":null,"code":"var assert = require('assert');\n\nvar translate = require('./translate.js');\n\nvar requireFromString = require('require-from-string');\n\nvar https = require('follow-redirects').https;\n\nvar MemoryStream = require('memorystream');\n\nvar semver = require('semver');\n\nfunction setupMethods(soljson) {\n  var version;\n\n  if ('_solidity_version' in soljson) {\n    version = soljson.cwrap('solidity_version', 'string', []);\n  } else {\n    version = soljson.cwrap('version', 'string', []);\n  }\n\n  var versionToSemver = function () {\n    return translate.versionToSemver(version());\n  };\n\n  var isVersion6 = semver.gt(versionToSemver(), '0.5.99');\n  var license;\n\n  if ('_solidity_license' in soljson) {\n    license = soljson.cwrap('solidity_license', 'string', []);\n  } else if ('_license' in soljson) {\n    license = soljson.cwrap('license', 'string', []);\n  } else {\n    // pre 0.4.14\n    license = function () {// return undefined\n    };\n  }\n\n  var alloc;\n\n  if ('_solidity_alloc' in soljson) {\n    alloc = soljson.cwrap('solidity_alloc', 'number', ['number']);\n  } else {\n    alloc = soljson._malloc;\n    assert(alloc, 'Expected malloc to be present.');\n  }\n\n  var reset;\n\n  if ('_solidity_reset' in soljson) {\n    reset = soljson.cwrap('solidity_reset', null, []);\n  }\n\n  var copyToCString = function (str, ptr) {\n    var length = soljson.lengthBytesUTF8(str); // This is allocating memory using solc's allocator.\n    //\n    // Before 0.6.0:\n    //   Assuming copyToCString is only used in the context of wrapCallback, solc will free these pointers.\n    //   See https://github.com/ethereum/solidity/blob/v0.5.13/libsolc/libsolc.h#L37-L40\n    //\n    // After 0.6.0:\n    //   The duty is on solc-js to free these pointers. We accomplish that by calling `reset` at the end.\n\n    var buffer = alloc(length + 1);\n    soljson.stringToUTF8(str, buffer, length + 1);\n    soljson.setValue(ptr, buffer, '*');\n  }; // This is to support multiple versions of Emscripten.\n  // Take a single `ptr` and returns a `str`.\n\n\n  var copyFromCString = soljson.UTF8ToString || soljson.Pointer_stringify;\n\n  var wrapCallback = function (callback) {\n    assert(typeof callback === 'function', 'Invalid callback specified.');\n    return function (data, contents, error) {\n      var result = callback(copyFromCString(data));\n\n      if (typeof result.contents === 'string') {\n        copyToCString(result.contents, contents);\n      }\n\n      if (typeof result.error === 'string') {\n        copyToCString(result.error, error);\n      }\n    };\n  };\n\n  var wrapCallbackWithKind = function (callback) {\n    assert(typeof callback === 'function', 'Invalid callback specified.');\n    return function (context, kind, data, contents, error) {\n      // Must be a null pointer.\n      assert(context === 0, 'Callback context must be null.');\n      var result = callback(copyFromCString(kind), copyFromCString(data));\n\n      if (typeof result.contents === 'string') {\n        copyToCString(result.contents, contents);\n      }\n\n      if (typeof result.error === 'string') {\n        copyToCString(result.error, error);\n      }\n    };\n  }; // This calls compile() with args || cb\n\n\n  var runWithCallbacks = function (callbacks, compile, args) {\n    if (callbacks) {\n      assert(typeof callbacks === 'object', 'Invalid callback object specified.');\n    } else {\n      callbacks = {};\n    }\n\n    var readCallback = callbacks.import;\n\n    if (readCallback === undefined) {\n      readCallback = function (data) {\n        return {\n          error: 'File import callback not supported'\n        };\n      };\n    }\n\n    var singleCallback;\n\n    if (isVersion6) {\n      // After 0.6.x multiple kind of callbacks are supported.\n      var smtSolverCallback = callbacks.smtSolver;\n\n      if (smtSolverCallback === undefined) {\n        smtSolverCallback = function (data) {\n          return {\n            error: 'SMT solver callback not supported'\n          };\n        };\n      }\n\n      singleCallback = function (kind, data) {\n        if (kind === 'source') {\n          return readCallback(data);\n        } else if (kind === 'smt-query') {\n          return smtSolverCallback(data);\n        } else {\n          assert(false, 'Invalid callback kind specified.');\n        }\n      };\n\n      singleCallback = wrapCallbackWithKind(singleCallback);\n    } else {\n      // Old Solidity version only supported imports.\n      singleCallback = wrapCallback(readCallback);\n    } // This is to support multiple versions of Emscripten.\n\n\n    var addFunction = soljson.addFunction || soljson.Runtime.addFunction;\n    var removeFunction = soljson.removeFunction || soljson.Runtime.removeFunction;\n    var cb = addFunction(singleCallback, 'viiiii');\n    var output;\n\n    try {\n      args.push(cb);\n\n      if (isVersion6) {\n        // Callback context.\n        args.push(null);\n      }\n\n      output = compile.apply(undefined, args);\n    } catch (e) {\n      removeFunction(cb);\n      throw e;\n    }\n\n    removeFunction(cb);\n\n    if (reset) {\n      // Explicitly free memory.\n      //\n      // NOTE: cwrap() of \"compile\" will copy the returned pointer into a\n      //       Javascript string and it is not possible to call free() on it.\n      //       reset() however will clear up all allocations.\n      reset();\n    }\n\n    return output;\n  };\n\n  var compileJSON = null;\n\n  if ('_compileJSON' in soljson) {\n    // input (text), optimize (bool) -> output (jsontext)\n    compileJSON = soljson.cwrap('compileJSON', 'string', ['string', 'number']);\n  }\n\n  var compileJSONMulti = null;\n\n  if ('_compileJSONMulti' in soljson) {\n    // input (jsontext), optimize (bool) -> output (jsontext)\n    compileJSONMulti = soljson.cwrap('compileJSONMulti', 'string', ['string', 'number']);\n  }\n\n  var compileJSONCallback = null;\n\n  if ('_compileJSONCallback' in soljson) {\n    // input (jsontext), optimize (bool), callback (ptr) -> output (jsontext)\n    var compileInternal = soljson.cwrap('compileJSONCallback', 'string', ['string', 'number', 'number']);\n\n    compileJSONCallback = function (input, optimize, readCallback) {\n      return runWithCallbacks(readCallback, compileInternal, [input, optimize]);\n    };\n  }\n\n  var compileStandard = null;\n\n  if ('_compileStandard' in soljson) {\n    // input (jsontext), callback (ptr) -> output (jsontext)\n    var compileStandardInternal = soljson.cwrap('compileStandard', 'string', ['string', 'number']);\n\n    compileStandard = function (input, readCallback) {\n      return runWithCallbacks(readCallback, compileStandardInternal, [input]);\n    };\n  }\n\n  if ('_solidity_compile' in soljson) {\n    var solidityCompile;\n\n    if (isVersion6) {\n      // input (jsontext), callback (ptr), callback_context (ptr) -> output (jsontext)\n      solidityCompile = soljson.cwrap('solidity_compile', 'string', ['string', 'number', 'number']);\n    } else {\n      // input (jsontext), callback (ptr) -> output (jsontext)\n      solidityCompile = soljson.cwrap('solidity_compile', 'string', ['string', 'number']);\n    }\n\n    compileStandard = function (input, callbacks) {\n      return runWithCallbacks(callbacks, solidityCompile, [input]);\n    };\n  } // Expects a Standard JSON I/O but supports old compilers\n\n\n  var compileStandardWrapper = function (input, readCallback) {\n    if (compileStandard !== null) {\n      return compileStandard(input, readCallback);\n    }\n\n    function formatFatalError(message) {\n      return JSON.stringify({\n        errors: [{\n          'type': 'JSONError',\n          'component': 'solcjs',\n          'severity': 'error',\n          'message': message,\n          'formattedMessage': 'Error: ' + message\n        }]\n      });\n    }\n\n    try {\n      input = JSON.parse(input);\n    } catch (e) {\n      return formatFatalError('Invalid JSON supplied: ' + e.message);\n    }\n\n    if (input['language'] !== 'Solidity') {\n      return formatFatalError('Only \"Solidity\" is supported as a language.');\n    } // NOTE: this is deliberately `== null`\n\n\n    if (input['sources'] == null || input['sources'].length === 0) {\n      return formatFatalError('No input sources specified.');\n    }\n\n    function isOptimizerEnabled(input) {\n      return input['settings'] && input['settings']['optimizer'] && input['settings']['optimizer']['enabled'];\n    }\n\n    function translateSources(input) {\n      var sources = {};\n\n      for (var source in input['sources']) {\n        if (input['sources'][source]['content'] !== null) {\n          sources[source] = input['sources'][source]['content'];\n        } else {\n          // force failure\n          return null;\n        }\n      }\n\n      return sources;\n    }\n\n    function librariesSupplied(input) {\n      if (input['settings']) {\n        return input['settings']['libraries'];\n      }\n    }\n\n    function translateOutput(output, libraries) {\n      try {\n        output = JSON.parse(output);\n      } catch (e) {\n        return formatFatalError('Compiler returned invalid JSON: ' + e.message);\n      }\n\n      output = translate.translateJsonCompilerOutput(output, libraries);\n\n      if (output == null) {\n        return formatFatalError('Failed to process output.');\n      }\n\n      return JSON.stringify(output);\n    }\n\n    var sources = translateSources(input);\n\n    if (sources === null || Object.keys(sources).length === 0) {\n      return formatFatalError('Failed to process sources.');\n    } // Try linking if libraries were supplied\n\n\n    var libraries = librariesSupplied(input); // Try to wrap around old versions\n\n    if (compileJSONCallback !== null) {\n      return translateOutput(compileJSONCallback(JSON.stringify({\n        'sources': sources\n      }), isOptimizerEnabled(input), readCallback), libraries);\n    }\n\n    if (compileJSONMulti !== null) {\n      return translateOutput(compileJSONMulti(JSON.stringify({\n        'sources': sources\n      }), isOptimizerEnabled(input)), libraries);\n    } // Try our luck with an ancient compiler\n\n\n    if (compileJSON !== null) {\n      if (Object.keys(sources).length !== 1) {\n        return formatFatalError('Multiple sources provided, but compiler only supports single input.');\n      }\n\n      return translateOutput(compileJSON(sources[Object.keys(sources)[0]], isOptimizerEnabled(input)), libraries);\n    }\n\n    return formatFatalError('Compiler does not support any known interface.');\n  };\n\n  return {\n    version: version,\n    semver: versionToSemver,\n    license: license,\n    lowlevel: {\n      compileSingle: compileJSON,\n      compileMulti: compileJSONMulti,\n      compileCallback: compileJSONCallback,\n      compileStandard: compileStandard\n    },\n    features: {\n      legacySingleInput: compileJSON !== null,\n      multipleInputs: compileJSONMulti !== null || compileStandard !== null,\n      importCallback: compileJSONCallback !== null || compileStandard !== null,\n      nativeStandardJSON: compileStandard !== null\n    },\n    compile: compileStandardWrapper,\n    // Loads the compiler of the given version from the github repository\n    // instead of from the local filesystem.\n    loadRemoteVersion: function (versionString, cb) {\n      var mem = new MemoryStream(null, {\n        readable: false\n      });\n      var url = 'https://binaries.soliditylang.org/bin/soljson-' + versionString + '.js';\n      https.get(url, function (response) {\n        if (response.statusCode !== 200) {\n          cb(new Error('Error retrieving binary: ' + response.statusMessage));\n        } else {\n          response.pipe(mem);\n          response.on('end', function () {\n            cb(null, setupMethods(requireFromString(mem.toString(), 'soljson-' + versionString + '.js')));\n          });\n        }\n      }).on('error', function (error) {\n        cb(error);\n      });\n    },\n    // Use this if you want to add wrapper functions around the pure module.\n    setupMethods: setupMethods\n  };\n}\n\nmodule.exports = setupMethods;","map":{"version":3,"sources":["/home/codaruuu/Desktop/reactClient/remixclient/node_modules/solc/wrapper.js"],"names":["assert","require","translate","requireFromString","https","MemoryStream","semver","setupMethods","soljson","version","cwrap","versionToSemver","isVersion6","gt","license","alloc","_malloc","reset","copyToCString","str","ptr","length","lengthBytesUTF8","buffer","stringToUTF8","setValue","copyFromCString","UTF8ToString","Pointer_stringify","wrapCallback","callback","data","contents","error","result","wrapCallbackWithKind","context","kind","runWithCallbacks","callbacks","compile","args","readCallback","import","undefined","singleCallback","smtSolverCallback","smtSolver","addFunction","Runtime","removeFunction","cb","output","push","apply","e","compileJSON","compileJSONMulti","compileJSONCallback","compileInternal","input","optimize","compileStandard","compileStandardInternal","solidityCompile","compileStandardWrapper","formatFatalError","message","JSON","stringify","errors","parse","isOptimizerEnabled","translateSources","sources","source","librariesSupplied","translateOutput","libraries","translateJsonCompilerOutput","Object","keys","lowlevel","compileSingle","compileMulti","compileCallback","features","legacySingleInput","multipleInputs","importCallback","nativeStandardJSON","loadRemoteVersion","versionString","mem","readable","url","get","response","statusCode","Error","statusMessage","pipe","on","toString","module","exports"],"mappings":"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","sourcesContent":["var assert = require('assert');\nvar translate = require('./translate.js');\nvar requireFromString = require('require-from-string');\nvar https = require('follow-redirects').https;\nvar MemoryStream = require('memorystream');\nvar semver = require('semver');\n\nfunction setupMethods (soljson) {\n  var version;\n  if ('_solidity_version' in soljson) {\n    version = soljson.cwrap('solidity_version', 'string', []);\n  } else {\n    version = soljson.cwrap('version', 'string', []);\n  }\n\n  var versionToSemver = function () {\n    return translate.versionToSemver(version());\n  };\n\n  var isVersion6 = semver.gt(versionToSemver(), '0.5.99');\n\n  var license;\n  if ('_solidity_license' in soljson) {\n    license = soljson.cwrap('solidity_license', 'string', []);\n  } else if ('_license' in soljson) {\n    license = soljson.cwrap('license', 'string', []);\n  } else {\n    // pre 0.4.14\n    license = function () {\n      // return undefined\n    };\n  }\n\n  var alloc;\n  if ('_solidity_alloc' in soljson) {\n    alloc = soljson.cwrap('solidity_alloc', 'number', [ 'number' ]);\n  } else {\n    alloc = soljson._malloc;\n    assert(alloc, 'Expected malloc to be present.');\n  }\n\n  var reset;\n  if ('_solidity_reset' in soljson) {\n    reset = soljson.cwrap('solidity_reset', null, []);\n  }\n\n  var copyToCString = function (str, ptr) {\n    var length = soljson.lengthBytesUTF8(str);\n    // This is allocating memory using solc's allocator.\n    //\n    // Before 0.6.0:\n    //   Assuming copyToCString is only used in the context of wrapCallback, solc will free these pointers.\n    //   See https://github.com/ethereum/solidity/blob/v0.5.13/libsolc/libsolc.h#L37-L40\n    //\n    // After 0.6.0:\n    //   The duty is on solc-js to free these pointers. We accomplish that by calling `reset` at the end.\n    var buffer = alloc(length + 1);\n    soljson.stringToUTF8(str, buffer, length + 1);\n    soljson.setValue(ptr, buffer, '*');\n  };\n\n  // This is to support multiple versions of Emscripten.\n  // Take a single `ptr` and returns a `str`.\n  var copyFromCString = soljson.UTF8ToString || soljson.Pointer_stringify;\n\n  var wrapCallback = function (callback) {\n    assert(typeof callback === 'function', 'Invalid callback specified.');\n    return function (data, contents, error) {\n      var result = callback(copyFromCString(data));\n      if (typeof result.contents === 'string') {\n        copyToCString(result.contents, contents);\n      }\n      if (typeof result.error === 'string') {\n        copyToCString(result.error, error);\n      }\n    };\n  };\n\n  var wrapCallbackWithKind = function (callback) {\n    assert(typeof callback === 'function', 'Invalid callback specified.');\n    return function (context, kind, data, contents, error) {\n      // Must be a null pointer.\n      assert(context === 0, 'Callback context must be null.');\n      var result = callback(copyFromCString(kind), copyFromCString(data));\n      if (typeof result.contents === 'string') {\n        copyToCString(result.contents, contents);\n      }\n      if (typeof result.error === 'string') {\n        copyToCString(result.error, error);\n      }\n    };\n  };\n\n  // This calls compile() with args || cb\n  var runWithCallbacks = function (callbacks, compile, args) {\n    if (callbacks) {\n      assert(typeof callbacks === 'object', 'Invalid callback object specified.');\n    } else {\n      callbacks = {};\n    }\n\n    var readCallback = callbacks.import;\n    if (readCallback === undefined) {\n      readCallback = function (data) {\n        return {\n          error: 'File import callback not supported'\n        };\n      };\n    }\n\n    var singleCallback;\n    if (isVersion6) {\n      // After 0.6.x multiple kind of callbacks are supported.\n      var smtSolverCallback = callbacks.smtSolver;\n      if (smtSolverCallback === undefined) {\n        smtSolverCallback = function (data) {\n          return {\n            error: 'SMT solver callback not supported'\n          };\n        };\n      }\n\n      singleCallback = function (kind, data) {\n        if (kind === 'source') {\n          return readCallback(data);\n        } else if (kind === 'smt-query') {\n          return smtSolverCallback(data);\n        } else {\n          assert(false, 'Invalid callback kind specified.');\n        }\n      };\n\n      singleCallback = wrapCallbackWithKind(singleCallback);\n    } else {\n      // Old Solidity version only supported imports.\n      singleCallback = wrapCallback(readCallback);\n    }\n\n    // This is to support multiple versions of Emscripten.\n    var addFunction = soljson.addFunction || soljson.Runtime.addFunction;\n    var removeFunction = soljson.removeFunction || soljson.Runtime.removeFunction;\n\n    var cb = addFunction(singleCallback, 'viiiii');\n    var output;\n    try {\n      args.push(cb);\n      if (isVersion6) {\n        // Callback context.\n        args.push(null);\n      }\n      output = compile.apply(undefined, args);\n    } catch (e) {\n      removeFunction(cb);\n      throw e;\n    }\n    removeFunction(cb);\n    if (reset) {\n      // Explicitly free memory.\n      //\n      // NOTE: cwrap() of \"compile\" will copy the returned pointer into a\n      //       Javascript string and it is not possible to call free() on it.\n      //       reset() however will clear up all allocations.\n      reset();\n    }\n    return output;\n  };\n\n  var compileJSON = null;\n  if ('_compileJSON' in soljson) {\n    // input (text), optimize (bool) -> output (jsontext)\n    compileJSON = soljson.cwrap('compileJSON', 'string', ['string', 'number']);\n  }\n\n  var compileJSONMulti = null;\n  if ('_compileJSONMulti' in soljson) {\n    // input (jsontext), optimize (bool) -> output (jsontext)\n    compileJSONMulti = soljson.cwrap('compileJSONMulti', 'string', ['string', 'number']);\n  }\n\n  var compileJSONCallback = null;\n  if ('_compileJSONCallback' in soljson) {\n    // input (jsontext), optimize (bool), callback (ptr) -> output (jsontext)\n    var compileInternal = soljson.cwrap('compileJSONCallback', 'string', ['string', 'number', 'number']);\n    compileJSONCallback = function (input, optimize, readCallback) {\n      return runWithCallbacks(readCallback, compileInternal, [ input, optimize ]);\n    };\n  }\n\n  var compileStandard = null;\n  if ('_compileStandard' in soljson) {\n    // input (jsontext), callback (ptr) -> output (jsontext)\n    var compileStandardInternal = soljson.cwrap('compileStandard', 'string', ['string', 'number']);\n    compileStandard = function (input, readCallback) {\n      return runWithCallbacks(readCallback, compileStandardInternal, [ input ]);\n    };\n  }\n  if ('_solidity_compile' in soljson) {\n    var solidityCompile;\n    if (isVersion6) {\n      // input (jsontext), callback (ptr), callback_context (ptr) -> output (jsontext)\n      solidityCompile = soljson.cwrap('solidity_compile', 'string', ['string', 'number', 'number']);\n    } else {\n      // input (jsontext), callback (ptr) -> output (jsontext)\n      solidityCompile = soljson.cwrap('solidity_compile', 'string', ['string', 'number']);\n    }\n    compileStandard = function (input, callbacks) {\n      return runWithCallbacks(callbacks, solidityCompile, [ input ]);\n    };\n  }\n\n  // Expects a Standard JSON I/O but supports old compilers\n  var compileStandardWrapper = function (input, readCallback) {\n    if (compileStandard !== null) {\n      return compileStandard(input, readCallback);\n    }\n\n    function formatFatalError (message) {\n      return JSON.stringify({\n        errors: [\n          {\n            'type': 'JSONError',\n            'component': 'solcjs',\n            'severity': 'error',\n            'message': message,\n            'formattedMessage': 'Error: ' + message\n          }\n        ]\n      });\n    }\n\n    try {\n      input = JSON.parse(input);\n    } catch (e) {\n      return formatFatalError('Invalid JSON supplied: ' + e.message);\n    }\n\n    if (input['language'] !== 'Solidity') {\n      return formatFatalError('Only \"Solidity\" is supported as a language.');\n    }\n\n    // NOTE: this is deliberately `== null`\n    if (input['sources'] == null || input['sources'].length === 0) {\n      return formatFatalError('No input sources specified.');\n    }\n\n    function isOptimizerEnabled (input) {\n      return input['settings'] && input['settings']['optimizer'] && input['settings']['optimizer']['enabled'];\n    }\n\n    function translateSources (input) {\n      var sources = {};\n      for (var source in input['sources']) {\n        if (input['sources'][source]['content'] !== null) {\n          sources[source] = input['sources'][source]['content'];\n        } else {\n          // force failure\n          return null;\n        }\n      }\n      return sources;\n    }\n\n    function librariesSupplied (input) {\n      if (input['settings']) {\n        return input['settings']['libraries'];\n      }\n    }\n\n    function translateOutput (output, libraries) {\n      try {\n        output = JSON.parse(output);\n      } catch (e) {\n        return formatFatalError('Compiler returned invalid JSON: ' + e.message);\n      }\n      output = translate.translateJsonCompilerOutput(output, libraries);\n      if (output == null) {\n        return formatFatalError('Failed to process output.');\n      }\n      return JSON.stringify(output);\n    }\n\n    var sources = translateSources(input);\n    if (sources === null || Object.keys(sources).length === 0) {\n      return formatFatalError('Failed to process sources.');\n    }\n\n    // Try linking if libraries were supplied\n    var libraries = librariesSupplied(input);\n\n    // Try to wrap around old versions\n    if (compileJSONCallback !== null) {\n      return translateOutput(compileJSONCallback(JSON.stringify({ 'sources': sources }), isOptimizerEnabled(input), readCallback), libraries);\n    }\n\n    if (compileJSONMulti !== null) {\n      return translateOutput(compileJSONMulti(JSON.stringify({ 'sources': sources }), isOptimizerEnabled(input)), libraries);\n    }\n\n    // Try our luck with an ancient compiler\n    if (compileJSON !== null) {\n      if (Object.keys(sources).length !== 1) {\n        return formatFatalError('Multiple sources provided, but compiler only supports single input.');\n      }\n      return translateOutput(compileJSON(sources[Object.keys(sources)[0]], isOptimizerEnabled(input)), libraries);\n    }\n\n    return formatFatalError('Compiler does not support any known interface.');\n  };\n\n  return {\n    version: version,\n    semver: versionToSemver,\n    license: license,\n    lowlevel: {\n      compileSingle: compileJSON,\n      compileMulti: compileJSONMulti,\n      compileCallback: compileJSONCallback,\n      compileStandard: compileStandard\n    },\n    features: {\n      legacySingleInput: compileJSON !== null,\n      multipleInputs: compileJSONMulti !== null || compileStandard !== null,\n      importCallback: compileJSONCallback !== null || compileStandard !== null,\n      nativeStandardJSON: compileStandard !== null\n    },\n    compile: compileStandardWrapper,\n    // Loads the compiler of the given version from the github repository\n    // instead of from the local filesystem.\n    loadRemoteVersion: function (versionString, cb) {\n      var mem = new MemoryStream(null, {readable: false});\n      var url = 'https://binaries.soliditylang.org/bin/soljson-' + versionString + '.js';\n      https.get(url, function (response) {\n        if (response.statusCode !== 200) {\n          cb(new Error('Error retrieving binary: ' + response.statusMessage));\n        } else {\n          response.pipe(mem);\n          response.on('end', function () {\n            cb(null, setupMethods(requireFromString(mem.toString(), 'soljson-' + versionString + '.js')));\n          });\n        }\n      }).on('error', function (error) {\n        cb(error);\n      });\n    },\n    // Use this if you want to add wrapper functions around the pure module.\n    setupMethods: setupMethods\n  };\n}\n\nmodule.exports = setupMethods;\n"]},"metadata":{},"sourceType":"script"}